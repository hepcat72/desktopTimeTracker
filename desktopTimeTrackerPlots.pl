#!/usr/bin/env perl -w

# This script processed the project log file generated by the applescript:
# desktopTimeTracker.osa which runs on a cron job every minute:
# * * * * * osascript /Users/rleach/desktopTimeTracker.osa >> project_log.txt


use CommandLineInterface;

setScriptInfo(VERSION => '1.0',
              CREATED => 'circa 2020',
              AUTHOR  => 'Robert Leach',
              CONTACT => 'rleach@princeton.edu',
              COMPANY => 'Princeton University',
              LICENSE => 'Copyright 2020',
              HELP    => 'Generate plots & plot data for ' .
              'desktopTimeTracker.  This script will generate tab-deliminted ' .
              'plotting data and it will attempt to generate and open ' .
              'graphical plots using gnuplot (a separate dependency).');

addInfileOption(GETOPTKEY => 'i|infile|project-log-file',
                SMRY_DESC => 'Input file generated using a ' .
                'desktopTimeTracker.osa cron job.',
                FORMAT    => 'Tab-delimited file.  See the comments at the ' .
                'top of desktopTimeTracker.osa for a description and ' .
                'examples of the format.');

my $sufftime = time();
my $o1 = addOutfileSuffixOption(GETOPTKEY => 'c|day-plot-data-suffix',
                                DEFAULT   => '.' . $sufftime . '.days.txt',
                                FORMAT    => 'Tab-delimited text file.');
my $o2 = addOutfileSuffixOption(GETOPTKEY => 'p|project-plot-data-suffix',
                                DEFAULT   => '.' . $sufftime . '.projects.txt',
                                FORMAT    => 'Tab-delimited text file.');
my $num_rec_days = undef;
addOption(GETOPTKEY => 'd|days=i',
          GETOPTVAL => \$num_rec_days,
          SMRY_DESC => 'Number of days to include.',
          DEFAULT   => 7);
my $workminspday = undef;
addOption(GETOPTKEY => 'm|workday-mins=i',
          GETOPTVAL => \$workminspday,
          SMRY_DESC => 'Number of minutes in a workday.',
          LONG_DESC => 'Number of minutes in a workday.  Note, there is no ' .
          'way to set a start or stop work time.  The intention is to infer ' .
          'work time based on desktop.  No matter what time of day, if you ' .
          'work on a desktop, that time is counted as woork on that ' .
          'project.  This max is only used to fill in idle time based on a ' .
          'lack of cursor movement.',
          DEFAULT   => 480);
my $inactmin = undef;
addOption(GETOPTKEY => 'b|minimum-idle-count=i',
          GETOPTVAL => \$inactmin,
          SMRY_DESC => 'Minimum number of intervals where no cursor movement ' .
          'is inferred to mean inactivity.',
          LONG_DESC => 'Minimum number of intervals (i.e. log entries) ' .
          'where no cursor movement is inferred to mean inactivity.  The ' .
          'duration (in time) depends on the logging frequency set up in ' .
          'the cron job.  If this option is set to 5, and there is a log ' .
          'entry once a minute, then after 5 minutes where the cursor has ' .
          'not moved, all time where the cursor was idle is counted as ' .
          'inactive time (i.e. you are not working).',
          DEFAULT   => 5);


my $dinf         = getInfile();
my $dof          = getOutfile($o1);
my $dof2         = getOutfile($o2);
my $lx           = -1;
my $ly           = -1;
my $inact        = 0;
my $wdys         = [qw(Sun Mon Tue Wed Thu Fri Sat)];
my $lastdt       = '';
my $inactstr     = 'inactive';
my $unmonstr     = 'unmonitored';
my $phash        = {$inactstr => 0};
my $startdate    = '';
my $stopdate     = '';

openIn(*IN,$dinf);
debug("Days: $num_rec_days");
while(getLine(*IN))
  {
    chomp;

    my($secs,$mpos,$dtop,$mntr,$app,$win,@custom_states) =
      split(/\t/,$_);
    ($secs,$mpos,$dtop,$mntr,$app,$win,@custom_states) =
      map {defined($_) ? $_ : 'unknown'}
        ($secs,$mpos,$dtop,$mntr,$app,$win,@custom_states);

    #Sometimes the window title puts a hard return in the log.
    #Skip those trailing lines where $secs is non-numeric:
    next if($secs !~ /^\d+$/);

    @custom_states = grep {$_ ne 'unknown' && $_ ne 'none'} @custom_states;
    my $custom_state = (scalar(@custom_states) ? $custom_states[0] : 'none');

    my($sec,$min,$hour,$mday,$mon,$year,$wday) = localtime($secs);

    $mon     += 1;
    $mon      = ('0'x(2-length($mon))).$mon;
    $year    += 1900;
    $mday     = ('0'x(2-length($mday))).$mday;
    $lastdt   = $dt = "$year/$mon/$mday-$wdys->[$wday]";
    my($x,$y) = split(/,/,$mpos);

    if(abs($x-$lx)<=1 || abs($y-$ly)<=1)
      {$inact++}
    else
      {$inact = 0}

    if($custom_state ne 'none')
      {
        if($inact <= $inactmin)
          {
            $h->{$dt}->{TOTAL}++;
            $h->{$dt}->{$custom_state}++;
          }
        else
          {$h->{$dt}->{$inactstr}++}
      }
    else
      {
        if($inact <= $inactmin)
          {
            $h->{$dt}->{TOTAL}++;
            $h->{$dt}->{$dtop}++;
          }
        else
          {$h->{$dt}->{$inactstr}++}
      }

    #Record the cursor's last coordinates for comparison in the next iteration
    $lx = $x;
    $ly = $y;
  }
closeIn(*IN);

#Limit to the most recent days
my $sorted_date_keys = [sort(keys(%$h))];
my $first_index      = $#{$sorted_date_keys} - $num_rec_days + 1;
$first_index         = 0 if($first_index < 0);
my $recent_hash      = {map {$_ => {%{$h->{$_}}}}
                        @{$sorted_date_keys}[$first_index..
                                             $#{$sorted_date_keys}]};

$startdate    = $sorted_date_keys->[$first_index];
$startdate    =~ s/-.*//;
my $sanistart = $startdate;
$sanistart    =~ s%/%_%g;

$stopdate     = $sorted_date_keys->[-1];
$stopdate     =~ s/-.*//;
my $sanistop  = $stopdate;
$sanistop     =~ s%/%_%g;

foreach my $dtr (keys(%$recent_hash))
  {foreach my $prjct (grep {$_ ne 'TOTAL'} keys(%{$recent_hash->{$dtr}}))
     {$phash->{$prjct} += $recent_hash->{$dtr}->{$prjct}}}



$dof =~ s/$sufftime/$sanistart-$sanistop/;

openOut(HANDLE => *OUT,
        FILE   => $dof,
        HEADER => 0) || exit(2);

#Print the column header
print("Date\t",
      join("\t",grep {$_ ne $inactstr && $_ ne 'TOTAL'} sort(keys(%$phash))),
      "\t$inactstr\n");

#Print the data
foreach my $day (sort(keys(%$recent_hash)))
  {
    $inactive = $workminspday - $recent_hash->{$day}->{TOTAL};
    print("$day\t");
    foreach my $project (grep {$_ ne $inactstr && $_ ne 'TOTAL'}
                         sort(keys(%$phash)))
      {
        print((exists($recent_hash->{$day}->{$project}) ?
               $recent_hash->{$day}->{$project} : '0'),
              "\t");
      }
    print(($inactive > 0 && $day ne $lastdt ? $inactive : '0'),"\n");
  }

closeOut(*OUT);

#Create a plot with gnuplot and open the image it generates
plotDays($phash,$dof,$startdate,$stopdate);



$dof2 =~ s/$sufftime/$sanistart-$sanistop/;

openOut(HANDLE => *OUT,
        FILE   => $dof2,
        HEADER => 0) || exit(3);

foreach my $project (grep {$_ ne $inactstr && $_ ne 'TOTAL' && $_ ne $unmonstr}
                     sort(keys(%$phash)))
  {print("$project\t$phash->{$project}\n")}

closeOut(*OUT);

#Create a plot with gnuplot and open the image it generates
plotProjects($dof2,$startdate,$stopdate);



#Globals used: $sufftime
sub plotProjects
  {
    my $df        = $_[0];
    my $startdate = $_[1];
    my $stopdate  = $_[2];
    my $of        = "$df.png";
    my $ttl       = "Project Tracking $startdate - $stopdate";
    my $gsf       = "$of.gps";

    openOut(*SCPT,$gsf) || exit(4);
    my $gsc =<< "GNUPLOT";
set title "Project Tracking";
set colorsequence classic;
set terminal png tiny size 800,800 enhanced font "Verdana,18";
set output "$of";
set title "$ttl";
set title font ",18";
set auto x;
unset xtics;
set xtics font ", 18";
set xtics nomirror rotate by -45 scale 0;
set style data histogram;
set style fill solid border -1;
set boxwidth 0.75;
set ylabel "Time (minutes)";
set bmargin at screen 0.2;
plot "$df" u (\$0):2:(\$0):xtic(1) w boxes lc variable notitle;
GNUPLOT
    print($gsc);
    closeOut(*SCPT);

    `gnuplot $gsf && open "$of"`;
  }


#Globals used: $sufftime
sub plotDays
  {
    my $ph        = $_[0];
    my $df        = $_[1];
    my $startdate = $_[2];
    my $stopdate  = $_[3];
    my $of        = $df . '.png';
    my $ttl       = "Day Tracking $startdate - $stopdate";
    my $gsf       = "$of.gps";

    openOut(*SCPT,$gsf) || exit(5);

    my $ndcols   = scalar(grep {$_ ne 'TOTAL'} keys(%$ph));
    my $bar_cols =
      join(',',
           map {qq%"$df" u $_:xtic(1) title columnheader%} (2..(1+$ndcols)));

    my $gsc =<< "GNUPLOT";
set terminal png tiny size 800,800 enhanced font "Verdana,18";
set colorsequence classic;
set output "$of";
set title "$ttl";
set title font ",18";
set key font ",10";
set auto x;
unset xtics;
set xtics font ", 18";
set xtics nomirror rotate by -45 scale 0;
set style data histogram;
set style histogram rowstacked;
set style fill solid border -1;
set ylabel "Time (minutes)";
set boxwidth 0.75;
set bmargin at screen 0.2;
set yrange [0:800];
plot $bar_cols;
GNUPLOT

    print($gsc);
    closeOut(*SCPT);
    `gnuplot $gsf && open "$of"`;
  }
